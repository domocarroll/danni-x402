Build Wave 2B: Swarm Web Integration. Update the existing swarm engine to receive a SemanticWeb from discovery, route subgraphs to agents, and emit web_update SSE events as agents densify the web.

CONTEXT: Wave 1 just landed. Types at src/lib/types/semantic-web.ts, utilities at src/lib/discovery/web-builder.ts. The swarm engine already works — agents run in parallel via executeSwarm(). SwarmInput and AgentOutput now have an optional `web?: SemanticWeb` field (already added in Wave 1). Your job is to wire the web through the swarm pipeline.

FILES YOU OWN (edit ONLY these):
- src/lib/swarm/orchestrator.ts (UPDATE — pass subgraphs to agents, collect web outputs, merge)
- src/lib/swarm/utils.ts (UPDATE — add formatWebContext() to include subgraph in agent input)
- src/lib/swarm/agents/market-analyst.ts (UPDATE — pass subgraph, parse web from output)
- src/lib/swarm/agents/competitive-intel.ts (UPDATE — same pattern)
- src/lib/swarm/agents/cultural-resonance.ts (UPDATE — same pattern)
- src/lib/swarm/agents/brand-architect.ts (UPDATE — same pattern)
- src/lib/swarm/agents/danni-synthesis.ts (UPDATE — receives full web, outputs synthesized web)
- src/lib/swarm/streaming-tracker.ts (UPDATE — add web_update event emission)
- src/lib/swarm/prompts/market-analyst.txt (UPDATE — add semantic output section)
- src/lib/swarm/prompts/competitive-intel.txt (UPDATE — add semantic output section)
- src/lib/swarm/prompts/cultural-resonance.txt (UPDATE — add semantic output section)
- src/lib/swarm/prompts/brand-architect.txt (UPDATE — add semantic output section)
- src/lib/swarm/prompts/danni-synthesis.txt (UPDATE — add semantic output section)
- src/routes/api/danni/analyze/+server.ts (UPDATE — accept optional web in request body, pass to swarm)

Read CLAUDE.md for conventions. Read src/lib/types/semantic-web.ts for types. Read src/lib/discovery/web-builder.ts for extractAgentSubgraph(), mergeWebs(), parseWebFromJson(), formatWebForPrompt().

CRITICAL DESIGN:

1. SUBGRAPH ROUTING (in orchestrator.ts):
   Before launching each agent, extract its relevant subgraph using extractAgentSubgraph(web, agentName).
   Pass the subgraph via the agent's params. If no web provided (one-shot fallback), agents work exactly as before.

2. AGENT PROMPT UPDATE (all 5 prompts):
   Add a section at the END of each agent prompt:

   ---
   ## Semantic Output (REQUIRED)
   After your analysis, output a JSON block with new semantic nodes and edges you discovered:
   ```json
   {
     "nodes": [
       { "id": "unique_id", "label": "short label", "type": "fact|insight|tension|opportunity", "source": "market|competitive|cultural|brand", "module": "/strategy|/creative|/synthesize|/validate", "confidence": 0.0-1.0, "content": "detailed content" }
     ],
     "edges": [
       { "from": "node_id", "to": "node_id", "relationship": "supports|contradicts|enables|blocks|informs", "strength": 0.0-1.0 }
     ]
   }
   ```
   Create 3-8 nodes per analysis. Connect them to existing nodes where relationships exist. Use your agent's source type for new nodes.

3. AGENT RUNNER UPDATE (all 4 + synthesis):
   After getting LLM output, use parseWebFromJson(output) to extract the web. Include it in AgentOutput.web. If parsing returns empty web, that's fine — text output always works.

4. ORCHESTRATOR MERGE:
   After all agents complete, merge all their webs: start with input.web (or emptyWeb()), mergeWebs() each agent's output web. The final merged web goes into SwarmOutput (you'll need to add a web field to SwarmOutput interface if not present — but check first, it may already be there from Wave 1).

5. STREAMING WEB UPDATES:
   In streaming-tracker.ts, add:
   - SSEEvent type: { event: 'web_update'; agentName: string; nodesAdded: number; edgesAdded: number; timestamp: number }
   - Method: emitWebUpdate(agentName: string, nodesAdded: number, edgesAdded: number)
   Call this from orchestrator after each agent completes and its web is parsed.

6. ANALYZE ENDPOINT UPDATE:
   In +server.ts, update AnalyzeInputSchema to accept optional `web` field (SemanticWebSchema.optional()). Pass it through to executeSwarm({ brief, brand, industry, web }).

7. BACKWARD COMPATIBILITY:
   Everything must work WITHOUT a web (one-shot mode). If input.web is undefined, agents work exactly as before. The web is purely additive.

IMPLEMENTATION ORDER:
1. Update streaming-tracker.ts (add web_update event)
2. Update utils.ts (add formatWebContext helper)
3. Update all 5 agent prompts (add semantic output section)
4. Update all 5 agent runners (parse web from output, include in AgentOutput)
5. Update orchestrator.ts (subgraph routing, web merging, web_update emission)
6. Update analyze/+server.ts (accept web input)
7. Run `bun run check`

DO NOT:
- Modify src/lib/types/ (locked — Wave 1)
- Modify src/lib/discovery/ (locked — Wave 2A)
- Modify any frontend files (Wave 2C's scope)
- Modify src/hooks.server.ts (locked)
- Break backward compatibility — one-shot mode MUST still work
- Use npm/yarn (use bun)
- Remove existing functionality
- Add SwarmOutput.web if it already exists in types
